\documentclass{article}

\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{moreverb}       % verbatim with tab

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{hmargin=2.5cm}
\usepackage{amsmath}
\usepackage{siunitx}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{lscape}

\usepackage{fancyhdr}       % en-têtes
\usepackage{lastpage}       % numéro de dernière page

\title{}

\title{Programmation procédurale\bigbreak \bigbreak
    \large Dossier 1\bigbreak
    \normalsize Création d’une base de données de clients\bigbreak}
\date{2020 -- 2021}
\author{Laura Binacchi}

\pagestyle{fancy}
\renewcommand\headrulewidth{1pt}
\fancyhead[L]{Laura Binacchi}
\fancyhead[C]{Programmation procédurale }
\fancyhead[R]{\today}


\begin{document}
    \pagenumbering{gobble}
    \includepdf[pages={1}]{pdg}
    \newpage
    \tableofcontents
    \newpage
    \pagenumbering{arabic}

    \section{Cahier des charges}
    \paragraph{}
    Sur base du schéma de base de données présenté ci-dessous et analysé au cours, concevoir et réaliser un programme en C sous CodeBlocks en mode console, géré par des menus simples. La base de données physique sera constituée d'un fichier binaire unique contenant toutes les données et les index nécessaires. Un fichier de trace listera les opérations réalisées sur la base.

    \paragraph{}
    Le logiciel devra supporter :
    \begin{itemize}[label=$\bullet$]
        \item La création de la base de données
        \item L’importation des 6 tables fournies sous forme de fichier .csv
        \item L’exportation de ces 6 tables sous forme de fichier .csv
        \item La création des index nécessaires aux requêtes précisées
        \item Des écrans permettant de lister l’information par recherche séquentielle pour les tables de codes
        \item Des écrans permettant d’afficher par recherche dichotomique
        \begin{itemize}[label=$\circ$]
            \item Une personne donnée par sa clé primaire
            \item Une compagnie donnée par sa clé primaire
        \end{itemize}
        \item Au moins un écran permettant d’afficher via une liste chainée en mémoire
        \begin{itemize}[label=$\circ$]
            \item Les personnes travaillant pour une compagnie donnée par sa clé primaire
            \item Les compagnies appartenant à un groupe donné
        \end{itemize}
        \item Au moins un écran utilisant un index binaire sur disque dans la recherche
        \begin{itemize}[label=$\circ$]
            \item Les personnes travaillant pour une compagnie donnée par sa clé primaire
            \item Les personnes dont le nom commence par une chaine donnée
        \end{itemize}
        \item Les listes chainées pourront être triées ascendant ou descendant
        \item Deux rapports répondants aux requêtes précisées ci-dessous
    \end{itemize}

    \paragraph{}
    Pour réduire la portée du projet, celui-ci sera essentiellement «read-only», une fois les données importées
dans la base.

    \paragraph{}
    On se concentrera sur:
    \begin{itemize}[label=$\bullet$]
        \item la création d’un fichier base de données unique, comme spécifié ultérieurement
        \item la recherche dichotomique pour les clés primaires de person et company
        \item la création d’un index sur la clé étrangère id\_cpy de la table person
        \item la création d’un index sur le nom de famille nm\_lst de la table person
        \item la génération de rapports, sous forme de fichiers textes formatés
        \item l’affichage en mode console des données via des listes chainées
    \end{itemize}

    \paragraph{}
    On ne demande pas :
    \begin{itemize}[label=$\bullet$]
        \item de modifier les données, mode «read-only»
        \item de modifier la structure et de rééquilibrer les arbres
        \item une interactivité poussée, les écrans en mode console seront propres et bien alignés mais simples
    \end{itemize}

    \paragraph{}
    On demande un rapport de détail et un rapport agrégé, par exemple :

    \paragraph{}
    Rapports de détail :
    \begin{itemize}[label=$\bullet$]
        \item Liste de toutes les personnes travaillant pour chaque compagnie d’un groupe
        \item Liste de toutes les compagnies appartenant à un groupe, par pays
    \end{itemize}

    \paragraph{}
    Rapports agrégés :
    \begin{itemize}[label=$\bullet$]
        \item Nombre de personnes par groupe (somme des nr\_emp) et nombre de personnes connues dans la DB (comptage des records personnes liés au groupe)
        \item Valeur totale des actions détenues par les employés pour un groupe donné, éclaté par par genre et niveau
        de fonction.
    \end{itemize}



    \newpage
    \section{Description du programme}

    \subsection{Fichier de base de données}
    Le programme est centré sur l'exploitation d'un fichier de base de données. Cette base de données est décrite dans le fichier \emph{catalog.h}. Le catalogue définit les différentes structures composant la base de données : les tables (\emph{country}, \emph{job}, \emph{industry}, \emph{group}, \emph{company} et \emph{person}), les index numériques et les index alphanumériques. Il définit également les tailles des champs de ces enregistrements\footnote{Ces tailles ont été déterminées en lançant l'exécutable \texttt{csv\_field\_length.sh}. Pour chaque fichier d'import, l'exécutable affiche la plus longue ligne et sa taille (utilisée pour définir la taille du buffer de lecture des fichiers \emph{csv}) et le plus long de chacun des champs et sa taille. Ces tailles sont adaptées avec ajout d'un filler pour faciliter la lecture du fichier binaire dans un éditeur hexadécimal.}.

    \paragraph{}
    Le catalogue définit le nombre d'emplacements réservés pour chaque table. Ils serviront à la création des enregistrements "vides"\footnote{Un enregistrement n'est jamais totalement vide puisqu'il a au minimum un type (ou préfixe).} en base de données, à la fois les enregistrements des tables et des index (un index portant sur la table \emph{person} doit avoir le même nombre d'emplacements réservés que cette table). Il définit où enregistrer les fichiers créés et où trouver les fichiers d'import.

    \paragraph{}
    Le catalogue définit enfin les structures de métadonnées sur les tables et les index dont les valeurs sont assignées dans le fichier \emph{catalog.c}. Ces métadonnées regroupent les informations spécifiques à chaque table comme le nom ou le préfixe à enregistrer en base de données et permettent la généricité de certaines fonctions. Par exemple, chaque table a une fonction d'import qui est appelée dans une boucle plutôt que de dupliquer le code d'import. Cette généricité rendra aussi plus facile l'ajout d'une nouvelle table.


    \subsection{Informations sur la base de données}
    \paragraph{}
    Certaines informations sur le fichier de base de données sont chargées en mémoire RAM. Elles sont regroupées dans la structure \emph{db} définie dans le fichier \emph{database.h}. Cette structure permet de passer un seul paramètre, son pointeur, aux différentes fonctions du programme pour accéder :
    \begin{itemize}[label=$\bullet$]
        \item au header de la base de données : ce header est enregistré au début du fichier de base de données et reprend les informations essentielles à l'exploitation du fichier (taille, nombre d'emplacements réservés et d'enregistrements dans chaque table, offsets des tables et des index);
        \item aux pointeurs de fichiers : fichier de base de données, de logs et fichier csv si un fichier d'import est ouvert;
        \item aux tables de codes chargées en mémoire : elles permettent un accès direct aux enregistrements (par identifiant) ou à toute la table plus rapidement que par une lecture dans le fichier de base de données.
    \end{itemize}

    \paragraph{}
    Le header et les tables de codes sont chargés en mémoire par la fonction d'ouverture de fichier implémentée dans \emph{open\_close.c}. Ils sont chargés à chaque fois que le fichier est ouvert en mode \emph{read} ou \emph{append}. En mode \emph{write}, ce sont les informations du header en mémoire RAM qui sont écrites dans le fichier de données.


    \subsection{Menus}
    \paragraph{}
    Conformément au cahier des charges, j'ai implémenté un menu en console afin d'accéder au fichier de base de données. Ce menu est programmé de manière déclarative : toutes les entrées de menu sont décrites dans un tableau et sont lancées par une fonction unique. Cette approche permet d'ajouter facilement une nouvelle entrée sans devoir modifier le code qui affiche les menus, attend une entrée de l'utilisateur et appelle les fonctions correspondantes.

    \paragraph{}
    Les menus sont divisés en deux catégories: ceux du mode utilisateur et ceux du mode d'administration. Le mode utilisateur regroupe les fonctionnalités d'exploitation de la base de données qui ne nécessitent qu'un accès \emph{read-only} au fichier. Le mode d'administration regroupe les fonctionnalités nécessitant un accès en écriture au fichier. Le mode d'accès au programme est défini par un argument passé au lancement de l'exécutable\footnote{Si le premier argument passé au main est la chaîne de caractères "admin", le programme est lancé en mode administrateur. Dans tous les autres cas, le programme est lancé en mode utilisateur.}.

    \paragraph{}
    Le fichier \emph{menu.h} définit la structure d'une entrée de menu avec le nom du menu et le pointeur de la fonction à appeler correspondant à ce menu. Un menu est composé d'une liste de ces entrées, du nombre d'entrées composant le menu et d'un titre. Les différents menus sont rassemblés dans un tableau. Le fichier \emph{menu.c} assigne des valeurs à ce tableau et implémente la fonction qui affiche le menu et appelle la fonction associée à l'entrée choisie par l'utilisateur.


    \subsection{Administration du fichier de base de données}
    \paragraph{}
    Le fichier \emph{admin.c} implémente les fonctions de création et de suppression du fichier de base de données. La création du fichier crée un nouveau fichier "vide" et écrase tout fichier existant si il y en avait un. Tout l'espace nécessaire au remplissage des données est réservé et rempli de \texttt{0} à l'exception du type d'enregistrement. Le header est rempli avec le nom de la base de données, le nombre d'emplacements réservés pour chaque table et les offsets des tables et des index, en mémoire et dans le fichier de données. Lors de la suppression du fichier via l'interface d'administration, le header gardé en mémoire est remis à zéro, ce qui ne serait pas le cas si le fichier était supprimé manuellement alors que le programme est en cours.

    \paragraph{}
    Ce fichier implémente aussi les fonctions d'import et d'export de données. Pour chaque table, l'import ouvre le fichier \emph{csv} d'import et écrit les données lues dans le fichier de données à partir de l'offset approprié. Le nom de ces fichiers et leur emplacement est défini par le catalogue dans les métadonnées des tables. L'import lance automatiquement la génération des index car ils sont nécessaires au fonctionnement de certaines fonctions d'exploitation de la base de données. Le fonctionnement des index est décrit au point suivant.

    \paragraph{}
    La fonction d'export recrée les fichiers \emph{csv} à partir du fichier de base de données. Il est essentiellement utilisé pour vérifier la validité des données importées (les fichiers d'import et d'export sont théoriquement identiques).

    \paragraph{}
    Le fichier \emph{admin.c} implémente enfin une fonction d'affichage des métadonnées de la base de données, i.e. des informations contenues dans le header. Cette entrée de menu est la seule qui soit partagée entre le mode d'administration et le mode d'exploitation de la base de données.


    \subsection{Index numérique, alphanumérique et arbre binaire}
    \paragraph{}
    Tous les index sont créés de la même manière que les tables à partir d'un tableau de métadonnées défini dans le catalogue. La création des index numériques est dissociée de celle des index alphanumériques car leurs structures sont différentes et surtout car l'index alphanumérique nécessite la création d'un arbre binaire. Les créations d'index sont respectivement implémentées dans les fichiers \emph{num\_index.c} et \emph{alpha\_index.c}.

    \paragraph{}
    Le mécanisme de création de l'index est commun aux deux types. Les fonctions de création d'index constituent ceux-ci à partir de la valeur sur laquelle porte l'index (identifiant de groupe ou de compagnie pour les index numériques et nom de famille des personnes pour l'index alphanumérique). Cette valeur est lue par la fonction de lecture définie dans les métadonnées : e.g. la lecture de \emph{id\_group} pour la constitutions de l'index \emph{company by group id}.

    \paragraph{}
    Après avoir constitué la liste de valeurs de l'index, cette liste va être triée par une fonction de tri \emph{quick sort} détaillée au point suivant. Cette liste triée est écrite dans le fichier de données.

    \paragraph{}
    Les index numériques créés de cette façon sont directement exploitables par une fonction de recherche dichotomique. Les index alphanumériques doivent quant à eux être représentés sous forme d'un arbre binaire équilibré dont la fonction de création est implémentée dans le fichier \emph{alpha\_index.c} selon l'algorithme récursif vu au cours. Chaque tuple de l'index enregistre l'offset des n\oe uds gauche et droit. L'offset du tuple racine de l'arbre est écrit dans le header du fichier de données et gardé en mémoire RAM. Il constitue le point d'entrée des recherches utilisant l'index alphanumérique.


    \subsection{Tri \emph{quick sort}}
    \paragraph{}
    La fonction de tri \emph{quick sort} vue au cours est implémentée dans le fichier \emph{sort.c}. La signature de la fonction est la même que celle de la fonction \emph{qsort} de la librairie standard \emph{stdlib} afin de  comparer facilement le temps d'exécution de la fonction implémentée par le programme et celle de la librairie standard.

    \paragraph{}
    La particularité de cette fonction est de trier un tableau d'éléments dont le type n'est pas connu. Le pointeur du tableau est passé en paramètre à la fonction avec le nombre d'éléments qui le composent et la taille d'un élément. Cette particularité rend impossible l'accès direct à un élément du tableau par un appel classique de type \texttt{tableau[i]}. Cet accès est implémenté par la fonction privée \texttt{void *\_elem(void *ptr, size\_t element\_size, size\_t i)}.

    \paragraph{}
    Les fonctions utilitaires privées sont appelées par l'intermédiaire de macros pour pouvoir être appelées sans leur passer des arguments qui sont toujours les mêmes. Par exemple, la fonction qui retourne un élément du tableau à un index donnée est définie comme suit :
    \begin{verbatimtab}
        #define QSORT_ELEM(__i) _elem(ptr, element_size, __i)
    \end{verbatimtab}
    Elle sera appelée uniquement dans la fonction privée \texttt{\_quick\_sort} où \texttt{ptr} (le pointeur du tableau à trier) et \texttt{element\_size} sont connus et ne changent pas. L'index \texttt{\_\_i} qui lui est différent à chaque appel est passé en paramètre à la macro.

    \paragraph{}
    Enfin, les éléments du tableau sont comparés par la fonction de comparaison passée en paramètre au \emph{quick sort}. Si besoin, ils sont intervertis par la fonction \texttt{\_swap}.


    \subsection{Fonctions de recherche}
    \paragraph{}
    Les fonctions de recherche sont des fonctions d'exploitation de la base de données. Elles sont donc accessibles uniquement via le mode utilisateur.

    \paragraph{}
    Les fonctions de recherches à proprement parler (séquentielle, dichotomique et par index) sont séparées des fonctions qui les exploitent, que ce soit pour l'affichage en console ou la génération de rapport. Ces fonctions de recherche sont implémentées dans le dossier \emph{search}, les affichages en console dans le dossier \emph{display\_search} et les rapports dans le dossier \emph{report}.

    \paragraph{}
    Les fonctions de recherche génériques du dossier \emph{search} renvoient des listes chainées de structures de type \texttt{search\_result} définie dans le fichier \emph{search\_result.h}. L'implémentation des listes chaînées est détaillée plus loin dans ce travail.

    \paragraph{}
    Il est enfin possible de trier les listes de résultats grâce à la fonction de tri implémentée dans le fichier \emph{search\_result.c}. Cette fonction générique prend en paramètres une liste de résultats et une fonction de comparaison. Elle utilise l'algorithme \emph{quick sort} après transformation de la liste chaînée en tableau.


    \subsection{Recherche par accès direct}
    \paragraph{}
    Les recherches par accès direct ne sont pas utilisées directement dans les menus de recherches mais par l'intermédiaire d'autres recherches. Par exemple, la génération du rapport des compagnies par groupe fait une recherche directe de groupe par l'identifiant cherché par l'utilisateur. La recherche directe est alors une recherche dans le buffer chargé en mémoire RAM.

    \paragraph{}
    L'implémentation d'une fonction de recherche directe ne nécessite pas d'implémentation particulière. En effet, il suffit d'accéder directement au tuple cherché par un appel classique dans le buffer de type \texttt{buffer[id-1]}. Pour une recherche directe dans le fichier de données, il aurait fallu implémenter une lecture dans le fichier de données sur base d'un offset calculé à partir de l'idendifiant recherché, de l'offset de la table et de la taille du tuple.


    \subsection{Recherche séquentielle}
    \paragraph{}
    Une fonction générique de recherche séquentielle est implémentée dans le fichier \emph{sequential\_search.c}. Elle constitue la liste de résultats à partir de la fonction de comparaison définie dans les métadonnées des tables.

    \paragraph{}
    Elle est exploitée par les recherches implémentées dans \emph{display\_sequential\_search.c} : recherches de pays, de job, d'industrie et de groupe par début de chaîne de caractère. Ces recherches demandent à l'utilisateur la chaîne de caractère cherchée pour rechercher :
    \begin{itemize}[label=$\bullet$]
        \item un pays par début de nom, de zone ou de code ISO (implémentation dans \emph{country.c})
        \item un job par début de nom, de niveau ou de département (implémentation dans \emph{job.c})
        \item une industrie par début de nom ou de secteur (implémentation dans \emph{industry.c})
        \item un groupe par début de nom (implémentation dans \emph{group.c})
    \end{itemize}

    \paragraph{}
    Toutes ces recherches sont insensibles à la casse.

    \paragraph{}
    La liste de résultats trouvés est affichée par une fonction générique de pagination implémentée dans \emph{ui\_utils.c}. Elle est triée par identifiant puisque les tuples sont parcourus séquentiellement et que les données sont triées sur base des identifiants. Elle est affichée à l'endroit ou à l'envers selon le choix de l'utilisateur (à l'endroit par défaut).


    \subsection{Recherche dichotomique}
    \paragraph{}
    Le fichier \emph{binary\_search.c} implémente la fonction générique de recherche dichotomique selon l'algorithme récursif vu au cours. Cet algorithme est utilisé pour les recherches par identifiant. Puisqu'il est unique, un seul résultat est retourné : l'offset du tuple trouvé ou celui du tuple le plus proche.

    \paragraph{}
    La recherche dichotomique est utilisée par la fonction générique \texttt{display\_search\_by\_id} du fichier \emph{display\_binary\_search.c}. Un identifiant est demandé à l'utilisateur et passé en paramètre à la recherche dichotomique. Si l'utilisateur entre \texttt{0}, le programme revient au menu principal n'effectue pas la recherche et l'utilisateur peut revenir au menu principal. Sinon, il affiche le tuple trouvé ou les trois tuples dont les identifiants sont les plus proches de celui cherché.

    \paragraph{}
    Il est à noter que la recherche de groupe par identifiant aurait plutôt pu être implémentée par un accès direct dans le buffer de groupes.


    \subsection{Recherche via index numérique}
    \paragraph{}
    Les index numériques sont exploités par la fonction de recherche implémentée dans \emph{num\_index\_search.c}. Cette fonction trouve la première occurrence correspondant à la recherche dans l'index et retourne la liste de résultats constituée à partir de cette première occurence.

    \paragraph{}
    Les recherches par index numérique affichées en console sont implémentées par une fonction générique dans le fichier \emph{display\_num\_index\_search.c} qui permet de chercher des personnes par identifiant de compagnie. L'identifiant est demandé à l'utilisateur et la liste est affichée par la fonction de pagination. Elle est triée par ordre alphabétique sur le nom de famille des personnes et est affichée à l'endroit ou à l'envers selon le choix de l'utilisateur.

    \paragraph{}
    Les rapports utilisent également la recherche numérique:
    \begin{itemize}[label=$\bullet$]
        \item Le rapport de compagnies par identifiant de groupe utilise l'index \emph{company by group id}
        \item Le rapport des employés d'un groupe classés par compagnie utilise l'index \emph{company by group id} pour trouver la liste des compagnies du groupe et l'index \emph{person by company id} pour trouver la liste des employés de chaque compagnie
        \item Le rapport du compte des employés d'un groupe utilise les mêmes index pour trouver les employés du groupe
        \item Le rapport sur les valeurs des actions détenues par les employés d'un groupe utilise les mêmes index pour trouver les employés du groupe
    \end{itemize}

    \paragraph{}
    Dans tous les cas, les listes de personnes sont triées par ordre alphabétique sur le nom de famille. Le programme n'intègre toutefois pas le tri dans la recherche par index numérique car une autre utilisation pourrait ne pas vouloir trier la liste ou la trier selon un autre champ.


    \subsection{Recherche via index alphanumérique}
    \paragraph{}
    La recherche par index alphanumérique est implémentée dans le fichier \emph{alpha\_index\_search.c}. De la même manière que la recherche par index numérique, elle retourne une liste de résultats à partir de la première occurrence correspondant à la recherche trouvée dans l'arbre binaire.

    \paragraph{}
    Cette recherche est utilisée dans \emph{display\_alpha\_index\_search.c} pour afficher la liste de personnes par début de nom. La liste n'est pas triée puisque l'index alphanumérique trie déjà les personnes par nom de famille. Ce tri est donc conservé à l'affichage et peut être inversé selon le choix de l'utilisateur.


    \subsection{Liste doublement chaînée}
    Le programme implémente une structure générique de liste doublement chaînée dont la structure est définie dans \emph{linked\_list.h}. Cette liste contient une donnée : un pointeur de \emph{void} qui peut donc correspondre à n'importe quel pointeur de donnée ou de structure. Elle contient le pointeur de l'élément suivant et de l'élément précédent.

    \paragraph{}
    Le fichier \emph{linked\_list.c} implémente les fonctions d'ajout d'un nouvel élément à la liste et de suppression de la liste, avec ou non une libération de la mémoire des données contenues dans la liste.


    \subsection{Logger}
    \paragraph{}
    Toutes les fonctions d'exploitation de la base de données écrivent des informations dans un fichier de log. Ce logger est implémenté dans le fichier \emph{logger.c} : il permet d'afficher un message d'erreur à la façon de \texttt{perror} en exploitant la valeur de \texttt{errno} ou d'afficher toute autre information précédée de l'endroit d'où provient le log. Les logs sont préfixés par la date et l'heure de l'écriture du log.



    \newpage
    \section{Structure de fichiers}
    \paragraph{}
    En résumé de la description du programme, voici la structure de fichiers de mon programme. Le dossier \emph{src} n'est pas développé pour ne pas répéter la structure de fichiers déjà détaillée dans le dossier \emph{include}. Seuls certains fichiers sont uniquement des headers et ne contiennent pas de prototype de fonction à implémenter dans les sources.

    \begin{verbatimtab}
    - data_clients (dossier créé par le programme)
        db_clients.dat (fichier de données binaires)
        db_clients.log (fichier de logs généré par l'application)
    - data_export (dossier créé par le programme lors de l'export de données)
        Company_Export_Datetime.csv (date et heure auxquelles le fichier a été généré)
        Country_Export_Datetime.csv
        Group_Export_Datetime.csv
        Industry_Export_Datetime.csv
        Job_Export_Datetime.csv
        Person_Export_Datetime.csv
    - data_import (dossier qui doit être présent avec les six fichiers d'import
                    au moment de l'import dans le fichier binaire de données)
        DB_Company.csv
        DB_Country.csv
        DB_Group.csv
        DB_Industry.csv
        DB_Job.csv
        DB_Person.csv
    - include (headers des fichiers sources)
        - db_file
            admin.h (fonctions d'administration de la base de données)
            alpha_index.h (création d'index alphanumérique utilisant un arbre binaire)
            catalog.h (définitions des structures des tuples et des métadonnées)
            database.h (définition des structures de données gardées en mémoire RAM)
            header.h (création du header pour une base de données vide)
            num_index.h (création d'un index numérique)
            open_close.h (fonctions d'ouverture et de fermeture du fichier de données)
        - display_search (recherches dont les résultats sont affichés en console)
            display_alpha_index_search.h
                recherche de personnes par nom de famille (tri par nom de famille)
            display_binary_search.h
                recherche d'un groupe par id
                recherche d'une compagnie par id
                recherche d'une personne par id
            display_num_index_search.h
                recherche de personnes par id de compagnie
            display_search.h (rassemble les headers pour simplifier les inclusions)
            display_sequential_search.h
                recherche par début de chaîne de caractère dans les tables de codes
                (pays, job, industrie, groupe)
        - report
            companies_by_group.h
                compagnies d'un groupe (par id) groupées par pays (rapport de détail)
            people_by_group.h
                employés d'un groupe (par id) groupés par compagnie (rapport de détail)
            people_count_by_group.h
                pourcentage d'employés connus d'un groupe par id (rapport agrégé)
            people_shares_sum.h
                somme d'actions détenues par les employés d'un groupe présentant
                les statistiques par niveau de fonction et par genre (rapport agrégé)
            report_file.h (création d'un fichier texte de rapport)
            report.h (rassemble les headers pour simplifier les inclusions)
        - search
            alpha_index_search.h (recherche par index alphanumérique générique)
            binary_search.h (recherche dichotomique générique)
            num_index_search.h (recherche par index numérique générique)
            search_result.h (structure des résultats de recherche et fonction de tri)
            sequential_search.h (fonction générique de recherche séquentielle)
        - table (fonctions de manipulation des tables)
            company.h
            country.h
            group.h
            industry.h
            job.h
            person.h
        - ui
            menus.h (menus déclaratifs)
            ui_utils.h (interface utilisateur)
                récupération d'inputs : nombre, chaîne de caractères, oui/non
                affichages : liste paginée, détails d'un record (ou résultat
                    le plus proche), pause du programme
        - utils
            linked_list.h (gestion de liste doublement chaînée générique)
            logger  .h (log d'information dans le fichier db_clients.log)
            preprocess_string.h (macro de transformation d'un nombre en string)
            sort.h (algorithme de tri quick sort)
            string_utils.h (fonctions utilitaires sur les chaînes de caractères :
                comparaisons, remplacement d'un caractère, mise en minuscules)
            system.h (fonction dépendant du système d'exploitation)
    + out (dossier dans lequel sont placés les fichiers objets compilés)
    + src (implémentations des headers, contient le main)
    + tests (fichiers de tests)
    Makefile (fichier utilisé pour compiler le projet)
    \end{verbatimtab}



    \section{Structure du fichier database}
    \paragraph{}
    Le fichier de données \emph{db\_clients.dat} est un fichier binaire d'une taille totale de 208 MB (208 224 128  bytes) composée de :
    \begin{itemize}[label=$\bullet$]
        \item un header (128 bytes)
        \item 100 tuples dans la table \emph{country} ($100 \times 64 \text{bytes} = 6400 \text{bytes}$)
        \item 200 tuples dans la table \emph{job} ($200 \times 96 \text{bytes} = 19200 \text{bytes}$)
        \item 100 tuples dans la table \emph{industry} ($100 \times 64 \text{bytes} = 6400 \text{bytes}$)
        \item 3000 tuples dans la table \emph{group} ($3000 \times 64 \text{bytes} = 192000 \text{bytes}$)
        \item 100 000 tuples dans la table \emph{company} ($100000 \times 288 \text{bytes} = 28800000 \text{bytes}$)
        \item 500 000 tuples dans la table \emph{person} ($500000 \times 224 \text{bytes} = 112000000 \text{bytes}$)
        \item 100 000 tuples dans l'index numérique \emph{company by group id} ($100000 \times 32 \text{bytes} = 3200000 \text{bytes}$)
        \item 500 000 tuples dans l'index numérique \emph{person by company id} ($500000 \times 32 \text{bytes} = 16000000 \text{bytes}$)
        \item 500 000 tuples dans l'index alphanumérique \emph{person by lastname} ($500000 \times 96 \text{bytes} = 48000000 \text{bytes}$)
    \end{itemize}



    \newpage
    \section{Tests}
    \paragraph{}
    Tous les tests du dossier \emph{tests} peuvent être compilés et lancés par le \emph{Makefile} avec la commande \texttt{make tests}. Les tests d'intégration peuvent être lancés avec la commande \texttt{make run\_integration\_tests} et les tests unitaires avec la commande \texttt{make run\_unit\_tests}.

    \subsection{Import des données}
    \paragraph{}
    Le processus complet de la création du fichier de données est testé par le fichier \emph{test\_create\_db.c} : création du fichier de données vide, import des données à partir des \emph{csv}, export, affichage des métadonnées et log des informations dans \emph{db\_client.log}. Ce test d'intégration est lancé par la commande \texttt{make run\_test/integrations/test\_create\_db}.

    \paragraph{}
    Comparer la taille réelle du fichier avec la taille calculée par le programme m'a permis de trouver une erreur au niveau de la création des index vides. Après correction, le fichier de données fait bien la taille calculée par le programme. Les offsets des différentes tables correspondent bien aux offset théoriques.

    \paragraph{}
    L'intégrité des données est vérifiée par comparaison avec les fichiers exportés. Les fichiers exportés sont légèrement plus petits que les fichiers d'import. En effet, les fichiers d'import contiennent un retour charriot qui a dû être supprimé pour le bon fonctionnement des affichages sous une distribution Linux.

    \paragraph{}
    La commande \texttt{diff --strip-trailing-cr import export} (où \texttt{import} et \texttt{export} sont remplacés par les noms des fichiers à tester) permet de vérifier que la présence ou non des retours charriots est bien la seule différence. Le fichier d'import des compagnies présente une différence supplémentaire : la présence d'espaces dans le champ \emph{am\_val}. L'ajout de l'argument \texttt{-w} à la commande \texttt{diff} permet de confirmer que c'est bien la seule différence.


    \subsection{Interface utilisateur}
    \paragraph{}
    Tous les éléments d'interface en console ont été testés en lançant le programme et en vérifiant que tout se déroulait correctement : menus, affichage des résultats, des listes, etc.

    \paragraph{}
    La navigation dans le menu a été testée en vérifiant évidemment que le menu affiché correspondait bien au menu choisi par l'utilisateur mais aussi en entrant des entrées non valides. Le menu tout comme les entrées de menu qui attendent un entier positif ne prennent en compte que le premier entier valide entré\footnote{Cette fonctionnalité est implémentée par la méthode \texttt{get\_uns\_input} du fichier \emph{ui\_utils.c}}. Le buffer de l'entrée standard est ensuite vidé pour ne pas tenir compte de tous les caractères suivants.

    \paragraph{}
    Le programme pourrait être amélioré en répétant cette opération avant la lecture d'une entrée utilisateur : dans l'état actuel du programme, il est possible d'entrer une donnée à un moment où elle n'est pas attendue et elle sera prise en compte par la prochaine fonction attendant une entrée. Si cette entrée n'est pas valide, elle sera ignorée avec affichage du message d'erreur. Sinon, elle est prise en compte et le programme effectue une action qui n'a pas forcément été demandée.


    \subsection{Cas d'erreur}
    \paragraph{}
    Les cas d'erreurs ont été testés en provoquant volontairement les erreurs, e.g. en lançant l'import de données sans fichier d'imports présents. Les possibilités de ce type d'erreurs ont été limitées au maximum en anticipant la possibilité qu'elle advienne, e.g. si le répertoire \emph{data\_export} n'existe pas, il est créé avant la création de fichiers d'export. S'il est impossible de prévenir ces erreurs, elles sont gérées par l'affichage d'un message d'erreur et le log de l'erreur.

    \paragraph{}
    Le fichiers de logs est un bon outil pour vérifier le bon fonctionnement du programme. L'écriture des logs appropriés a été testé tout au long de l'écriture du programme, si possible en provoquant volontairement les erreurs, sinon en modifiant les fonctions.


    \subsection{Test des recherches séquentielles}
    \paragraph{}
    Les recherches séquentielles sont testées par un test d'intégration qui est lancé par la commande \texttt{make run\_test/integrations/test\_sequential\_search}. Ce fichier teste  les recherches séquentielles détaillées dans la description du programme : recherche par début de chaîne de caractère de pays, job, industrie ou groupe.

    \paragraph{}
    Le test compare les résultats de la fonction \texttt{sequential\_search} avec les résultats normalement attendus. Les résultats attendus ont été déterminés par la commande \texttt{grep}\footnote{Toutes les commandes utilisées sont documentées dans le code du test.}.

    \paragraph{}
    Le test vérifie la conformité des données trouvées avec les données dans le cas normal d'utilisation mais aussi dans le cas ou aucun enregistrment correspondant n'est trouvé et le cas où tous les éléments sont retournés (lorsqu'une chaîne de caractère vide est cherchée comme préfixe).


    \subsection{Test des recherches dichotomiques}
    \paragraph{}
    Les recherches dichotomiques sont testées par le fichier \emph{test\_binary\_search.c} lancé par la commande \texttt{make run\_test/integrations/test\_binary\_search}. Il permet de tester que l'offset retourné correspond bien à celui de l'entité cherchée si l'identifiant existe ou de l'entité dont l'identifiant est le plus proche de celui cherché. Il vérifie également que si l'identifiant cherché est plus petit que le plus petit identifiant existant, c'est bien l'offset du premier enregistrement qui est renvoyé, et s'il est plus grand, c'est l'offset du dernier enregistrement qui est renvoyé.

    \paragraph{}
    L'affichage correct des trois résultats les plus proches a été testé manuellement en lançant l'application. En cas de valeurs limites, l'offset est ajusté correctement pour afficher trois entités valides. Si un identifiant plus petit que le plus petit identifiant enregistré dans le fichier de données est cherché, les trois premiers enregistrements de la base de données sont affichés (e.g. \texttt{1} est cherché dans le menu \texttt{[6] Search company by id}). Si un identifiant plus grand que le dernier identifiant enregistré est cherché, les trois derniers enregistrements sont affichés (e.g. \texttt{690000} est cherché dans le menu \texttt{[6] Search company by id}).


    \subsection{Test des recherches par index}
    \paragraph{}
    Les recherches par index numériques sont testées par le fichier \emph{test\_num\_index\_search.c} lancé par la commande \texttt{make run\_test/integrations/test\_num\_index\_search}. Il teste les recherches utilisant l'index de personne par identifiant de compagnie.

    \paragraph{}
    Il vérifie que les résultats trouvés correspondent bien aux résultats attendus, que la compagnie ait des employés enregistrés dans la base de données ou non. Les données attendues sont déterminées par la commande \texttt{grep} documentée dans le test. Le test vérifie également qu'aucun résultat n'est renvoyé si l'identifiant est invalide.

    \paragraph{}
    Les recherches par index alphanumériques sont testées par le fichier \emph{test\_alpha\_index\_search.c} lancé par la commande \texttt{make run\_test/integrations/test\_alpha\_index\_search}. Il teste les recherches utilisant l'index de personne par nom de famille de la même manière que le test de recherche par index numérique.


    \subsection{Tests unitaires}
    \paragraph{}
    Des tests unitaires permettent de tester les méthodes utilitaires suivantes :
    \begin{itemize}[label=$\bullet$]
        \item le tri \emph{quick sort}
        \item la création des listes chaînées et le tri des listes de résultats de recherches
        \item la fonction qui permet de déterminer si une chaîne de caractère contient une sous-chaîne recherchée (insensible à la casse)
        \item la fonction qui permet de déterminer si une chaîne de caractères commence par un préfixe donné
        \item le remplacement d'un caractère par un autre dasn une chaîne de caractère (utilisée pour la génération des noms de rapports)
        \item la mise en minuscules d'une chaîne de caractères
    \end{itemize}

    \paragraph{}
    Ces tests peuvent être lancés individuellement avec les commandes \texttt{make run\_test/units/test\_name}.


    \subsection{Valgrind}
    \paragraph{}
    Le programme a enfin été testé avec Valgrind afin de vérifier que tous les esapces de mémoire alloués lors de l'exécution du programme sont bien libérés. Pour effectuer ce test, j'ai lancé les commandes \texttt{valgrind --leak-check=full -s ./clients admin}\footnote{\texttt{leak-check=full} pour avoir des détails sur les fuites mémoires et \texttt{-s} pour avoir des détails sur les erreurs} et \texttt{valgrind --leak-check=full -s ./clients} et j'ai parcouru les fonctionalités du programme. J'aurais pu aussi lancer valgrind sur les tests d'intégrations.

    \paragraph{}
    Ce test a permis de mettre en évidence une erreur dans le main lorsde l'appel à la fonction d'ouverture du fichier de base de données. L'ouverture de la base de données dans n'importe quel mode ferme d'abord le pointeur de fichier. Cette opération ne pose pas de problème si le pointeur passé à \texttt{fclose} est nul mais lors du premier appel, le pointeur n'avais pas été initialisé. J'ai donc rajouté une initalisation du pointeur de fichier de données à \emph{NULL} dans le main.

    \paragraph{}
    L'espace alloué à la liste de tri temporaire de la fonction \texttt{sort\_linked\_list} du fichier \emph{search\_resul.c} n'avait pas été libéré. J'avais également oublié de libérée une liste chaînée dans la création du rapport sur les actions détenues par les employés d'un groupe.



    \newpage
    \section{Problèmes rencontrés}

    \subsection{Compatibilité entre Windows et Linux}
    \paragraph{}
    Durant le développement de l'application, j'ai été confrontée à de nombreux bugs dont certains ont été plus difficiles à trouver que d'autres. Dans la plupart des cas, les messages d'erreurs étaient assez clairs. Un des problèmes les plus difficiles à debugger auxquels j'ai été confrontée était un problème d'affichage : lors de l'affichage des listes de résultats, certains caractères et parfois certaines lignes entières étaient effacées alors que les données semblaient correctes.

    \paragraph{}
    Le problème était en fait un problème de compatibilité entre Windows et Linux : le retour à la ligne se fait sous Windows avec un retour charriot supplémentaire. J'ai réglé se problème dans les fonctions d'import des tables en testant la présence d'un \texttt{\textbackslash r} à la fin du dernier champ et en le remplaçant par un \texttt{0} si nécessaire.

    \paragraph{}
    J'ai essayé de rendre mon programme le plus compatible possible avec une distribution Windows. Les fonctions propres au système d'exploitation ont été évitées au maximum. Quand elles étaient nécessaires, elles ont été implémentées dans un \texttt{ifdef} qui teste l'OS. Celui-ci est également testé au lancement du programme pour empêcher le programme d'être lancé sous une distribution pour laquelle le programme n'a pas été conçu et pour laquelle il n'a donc pas été testé. Malgré cela, le programme a été testé uniquement sous une distribution Linux et pourrait donc présenter des bugs sous Windows.


    \subsection{Inclusions circulaires}
    \paragraph{}
    Certaines difficultés rencontrées sont liées à la taille du projet demandé. C'est la cas des inclusions circulaires : un premier fichier inclut un second qui lui-même inclut le premier. Cette difficulté a pu être contournée la plupart du temps par une modification de l'architecture du programme.

    \paragraph{}
    Le seul endroit où j'ai résolu ce problème différemment est dans les fichiers \emph{catalog.h} et \emph{database.h} qui s'incluent mutuellement. J'ai supprimé l'inclusion de \emph{database.h} dans \emph{catalog.h} en faisant une déclaration avancée de la structure \texttt{db}, à la manière de la déclaration d'un prototype de fonction avant son implémentation.


    \subsection{Gestion des erreurs}
    \paragraph{}
    La gestion des erreurs peut très vite alourdir le code. Elle est pourtant nécessaire à son bon fonctionnement. Par contre, il est impossible de gérer toutes les erreurs et ce n'est d'ailleurs pas souhaitable : certaines erreurs doivent arrêter le programme.

    \paragraph{}
    L'endroit du programme où sont gérées les erreurs a été difficile à déterminer. J'ai essayé de le faire de manière cohérente : les affichages des erreurs et les écritures de logs ne sont pas gérées dans les fonctions utilitaires mais dans les fonctions qui les appellent. En effet, les fonctions d'appel peuvent vouloir gérer les mêmes erreurs différemment. J'aurais également pu gérer le log des erreurs dans chaque fonction et l'affichage à l'utilisateur dans les fonctions d'interface utilisateur.


    \subsection{Généricité du code}
    \paragraph{}
    Enfin le bon degré de généricité à implémenter n'a pas toujours été facile à déterminer. Une analyse préalable du code m'a permis de déterminer de manière assez juste quand génériciser les fonctions mais je me suis trompée notamment dans la manière de découper les fonctions de recherche. J'avais inclus les affichages en console dans les fonctions de recherches alors que ces fonctions sont aussi appelées pour la génération des rapports, sans affichage des résultats donc.

    \paragraph{}
    Implémenter du code générique m'a pris plus de temps que de copier-coller le code des fonctions en l'adaptant. Le faire m'a pourtant permis d'aller beaucoup plus loin dans l'apprentissage du C, avec par exemple l'utilisation de pointeurs de fonctions ou encore avec l'utilisation du \emph{Makefile}, nécessaire pour compiler un projet avec autant de fichiers.
\end{document}
