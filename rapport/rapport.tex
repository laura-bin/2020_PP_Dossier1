\documentclass{article}

\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{moreverb}       % verbatim with tab

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{hmargin=2.5cm}
\usepackage{amsmath}
\usepackage{siunitx}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{enumitem}
\usepackage{lscape}

\usepackage{fancyhdr}       % en-têtes
\usepackage{lastpage}       % numéro de dernière page

\title{Programmation procédurale}
\date{2021}
\author{Laura Bin}

\pagestyle{fancy}
\renewcommand\headrulewidth{1pt}
\fancyhead[L]{Laura Binacchi}
\fancyhead[C]{Programmation procédurale }
\fancyhead[R]{\today}

\begin{document}
    \pagenumbering{arabic}
    \newpage
    \tableofcontents
    \newpage

    \section{Cahier des charges}
    \paragraph{}
    Sur base du schéma de base de données présenté ci-dessous et analysé au cours, concevoir et réaliser un programme en C sous CodeBlocks en mode console, géré par des menus simples. La base de données physique sera constituée d'un fichier binaire unique contenant toutes les données et les index nécessaires. Un fichier de trace listera les opérations réalisées sur la base.

    \paragraph{}
    Le logiciel devra supporter :
    \begin{itemize}[label=$\bullet$]
        \item La création de la base de données
        \item L’importation des 6 tables fournies sous forme de fichier .csv
        \item L’exportation de ces 6 tables sous forme de fichier .csv
        \item La création des index nécessaires aux requêtes précisées
        \item Des écrans permettant de lister l’information par recherche séquentielle pour les tables de codes
        \item Des écrans permettant d’afficher par recherche dichotomique
        \begin{itemize}[label=$\circ$]
            \item Une personne donnée par sa clé primaire
            \item Une compagnie donnée par sa clé primaire
        \end{itemize}
        \item Au moins un écran permettant d’afficher via une liste chainée en mémoire
        \begin{itemize}[label=$\circ$]
            \item Les personnes travaillant pour une compagnie donnée par sa clé primaire
            \item Les compagnies appartenant à un groupe donné
        \end{itemize}
        \item Au moins un écran utilisant un index binaire sur disque dans la recherche
        \begin{itemize}[label=$\circ$]
            \item Les personnes travaillant pour une compagnie donnée par sa clé primaire
            \item Les personnes dont le nom commence par une chaine donnée
        \end{itemize}
        \item Les listes chainées pourront être triées ascendant ou descendant
        \item Deux rapports répondants aux requêtes précisées ci-dessous
    \end{itemize}

    \paragraph{}
    Pour réduire la portée du projet, celui-ci sera essentiellement «read-only», une fois les données importées
dans la base.

    \paragraph{}
    On se concentrera sur:
    \begin{itemize}[label=$\bullet$]
        \item la création d’un fichier base de données unique, comme spécifié ultérieurement
        \item la recherche dichotomique pour les clés primaires de person et company
        \item la création d’un index sur la clé étrangère id\_cpy de la table person
        \item la création d’un index sur le nom de famille nm\_lst de la table person
        \item la génération de rapports, sous forme de fichiers textes formatés
        \item l’affichage en mode console des données via des listes chainées
    \end{itemize}

    \paragraph{}
    On ne demande pas :
    \begin{itemize}[label=$\bullet$]
        \item de modifier les données, mode «read-only»
        \item de modifier la structure et de rééquilibrer les arbres
        \item une interactivité poussée, les écrans en mode console seront propres et bien alignés mais simples
    \end{itemize}

    \paragraph{}
    On demande un rapport de détail et un rapport agrégé, par exemple :

    \paragraph{}
    Rapports de détail :
    \begin{itemize}[label=$\bullet$]
        \item Liste de toutes les personnes travaillant pour chaque compagnie d’un groupe
        \item Liste de toutes les compagnies appartenant à un groupe, par pays
    \end{itemize}

    \paragraph{}
    Rapports agrégés :
    \begin{itemize}[label=$\bullet$]
        \item Nombre de personnes par groupe (somme des nr\_emp) et nombre de personnes connues dans la DB (comptage des records personnes liés au groupe)
        \item Valeur totale des actions détenues par les employés pour un groupe donné, éclaté par par genre et niveau
        de fonction.
    \end{itemize}



    \newpage
    \section{Description du programme}

    \subsection{Fichier de base de données}
    Le programme est centré sur l'exploitation d'un fichier de base de données. Cette base de données est décrite dans le fichier \emph{catalog.h}. Le catalogue définit les différentes structures composant la base de données : les tables (\emph{country}, \emph{job}, \emph{industry}, \emph{group}, \emph{company} et \emph{person}), les index numériques et les index alphanumériques. Il définit également les tailles des champs de ces enregistrements\footnote{Ces tailles ont été déterminées en lançant l'exécutable \texttt{csv\_field\_length.sh}. Pour chaque fichier d'import, l'exécutable affiche la plus longue ligne et sa taille (utilisée pour définir la taille du buffer de lecture des fichiers \emph{csv}) et le plus long de chacun des champs et sa taille. Ces tailles sont adaptées avec ajout d'un filler pour faciliter la lecture du fichier binaire dans un éditeur hexadécimal.}.
    
    \paragraph{}
    Le catalogue définit le nombre d'emplacements réservés pour chaque table. Ils serviront à la création des enregistrements "vides"\footnote{Un enregistrement n'est jamais totalement vide puisqu'il a au minimum un type (ou préfixe).} en base de données, à la fois les enregistrements des tables et des index (un index portant sur la table \emph{person} doit avoir le même nombre d'emplacements réservés que cette table). Il définit où enregistrer les fichiers créés et où trouver les fichiers d'import.

    \paragraph{}
    Le catalogue définit enfin les structures de métadonnées sur les tables et les index dont les valeurs sont assignées dans le fichier \emph{catalog.c}. Ces métadonnées regroupe les informations spécifiques à chaque table comme le nom ou le préfixe à enregistrer en base de données et permettent la généricité de certaines fonctions. Par exemple, chaque table a une fonction d'import qui est appelée dans un boucle plutôt que de dupliquer le code d'import. Cette généricité rendra aussi plus facile l'ajout d'une nouvelle table.


    \subsection{Informations sur la base de données}
    \paragraph{}
    Certaines informations sur le fichier de base de données sont chargées en mémoire RAM. Elles sont regroupées dans la structure \emph{db} définie dans le fichier \emph{database.h}. Cette structure permet de passer un seul paramètre, son pointeur, aux différentes fonctions du programme pour accéder :
    \begin{itemize}[label=$\bullet$]
        \item au header de la base de données : ce header est enregistré au début du fichier de base de donnée et reprend les informations essentielles à l'exploitation du fichier (taille, nombre d'emplacements réservés et d'enregistrements dans chaque table, offsets des tables et des index);
        \item aux pointeurs de fichiers : fichier de base de données, de logs et fichier csv si un fichier d'import est ouvert;
        \item aux tables de codes chargées en mémoire : elles permettent un accès direct aux enregistrements (par identifiant) ou à toute la table plus rapidement que par une lecture dans le fichier de base de données.
    \end{itemize}

    \paragraph{}
    Le header et les tables de codes sont chargée en mémoire par la fonction d'ouverture de fichier implémentée dans \emph{open\_close.c} à chaque fois que le fichier est ouvert en mode \emph{read} ou \emph{append}. En mode \emph{write}, ce sont les informations du header en mémoire RAM qui sont écrites dans le fichier de données.


    \subsection{Menus}
    \paragraph{}
    Conformément au cahier des charges, j'ai implémenté un menu en console afin d'accéder au fichier de base de données. Ce menu est programmé de manière déclarative : toutes les entrées de menu sont décrites dans un tableau et sont lancées par une fonction unique. Cette approche permet d'ajouter facilement une nouvelle entrée sans devoir modifier le code qui affiche les menus, attend une entrée de l'utilisateur et appelle les fonctions correspondantes.

    \paragraph{}
    Les menus sont divisés en deux catégories: ceux du mode utilisateur et ceux du mode d'administration. Le mode utilisateur regroupe les fonctionnalités d'exploitation de la base de données qui ne nécessitent qu'un accès \emph{read-only} au fichier. Le mode d'administration regroupe les fonctionnalités nécessitant un accès en écriture au fichier. Le mode d'accès au programme est défini par un argument passé au lancement de l'exécutable\footnote{Si le premier argument passé au main est la chaîne de caractères "admin", le programme est lancé en mode administrateur. Dans tous les autres cas, le programme est lancé en mode utilisateur.}.

    \paragraph{}
    Le fichier \emph{menu.h} définit la structure d'une entrée de menu avec le nom du menu et le pointeur de la fonction à appeler correspondant à ce menu. Un menu est composé d'une liste de ces entrée, du nombre d'entrées composant le menu et d'un titre. Les différents menus sont rassemblés dans un tableau. Le fichier \emph{menu.c} assigne des valeurs à ce tableau et implémente la fonction qui affiche le menu et appelle la fonction associée à l'entrée choisie par l'utilisateur.


    \subsection{Administration du fichier de base de données}
    \paragraph{}
    Le fichier \emph{admin.c} implémente les fonctions de création et de suppression du fichier de base de données. La création du fichier crée un nouveau fichier "vide" et écrase tout fichier existant si il y en avait un. Tout l'espace nécessaire au remplissage des données est réservé et rempli de \texttt{0} à l'exception du type d'enregistrement. Le header est rempli avec le nom de la base de données, le nombre d'emplacements réservés pour chaque table et les offsets des tables et des index, en mémoire et dans le fichier de données. Lors de la suppression du fichier via l'interface d'administration, le header gardé en mémoire est remis à zéro, ce qui ne serait pas le cas si le fichier était supprimé manuellement alors que le programme est en cours.

    \paragraph{}
    Ce fichier implémente aussi les fonctions d'import et d'export de données. Pour chaque table, l'import ouvre le fichier \emph{csv} d'import et écrit les données lues dans le fichier de données à partir de l'offset approprié. Le nom de ces fichiers et leur emplacement est défini par le catalogue dans les métadonnées des tables. L'import lance automatiquement la génération des index car ils sont nécessaires au fonctionnement de certaines fonctions d'exploitation de la base de données. Le fonctionnement des index est décrit au point suivant.

    \paragraph{}
    La fonction d'export recrée les fichiers \emph{csv} à partir du fichier de base de données. Il est essentiellement utilisé pour vérifier la validité des données importées (les fichiers d'import et d'export doivent être identiques).

    \paragraph{}
    Le fichier \emph{admin.c} implémente enfin une fonction d'affichage des métadonnées de la base de données, i.e. des informations contenues dans le header. Cette entrée de menu est la seule qui soit partagée entre le mode d'administration et le mode d'exploitation de la base de données.


    \subsection{Index numériques, alphanumériques et arbre binaire}
    \paragraph{}
    Tous les index sont créés de la même manière que les tables à partir d'un tableau de métadonnées défini dans le catalogue. La création des index numériques est dissociée de celle des index alphanumériques car leurs structures sont différentes et l'index alphanumérique nécessite la création d'un arbre binaire. Elles sont respectivement implémentées dans les fichiers \emph{num\_index.c} et \emph{alpha\_index.c}.

    \paragraph{}
    Le mécanisme de création de l'index est commun aux deux types. Les fonctions de création d'index constituent ceux-ci à partir de la valeur sur laquelle porte l'index (identifiant de groupe ou de compagnie pour les index numériques et nom de famille des personnes pour l'index alphanumérique). Cette valeur est lue par la fonction de lecture définie dans les métadonnées : e.g. la lecture de \emph{id\_group} pour la constitutions de l'index \emph{company by group id}.

    \paragraph{}
    Après avoir constitué la liste de valeurs de l'index, cette liste va être triée par une fonction de tri \emph{quick sort} détaillée au point suivant. Cette liste triée est écrite dans le fichier de données.

    \paragraph{}
    Les index numériques crées de cette façon sont directement exploitables par une fonction de recherche dichotomique. Les index alphanumériques doivent quant à eux être représentés sous forme d'un arbre binaire équilibré dont la fonction de création est implémentée dans le fichier \emph{alpha\_index.c} selon l'algorithme récursif vu au cours. Chaque tuple de l'index enregistre l'offset des n\oe uds gauche et droit. L'offset du tuple racine de l'arbre est écrit dans le header du fichier de données et gardé en mémoire RAM. Il constitue le point d'entrée des recherches utilisant l'index alphanumérique.


    \subsection{Tri \emph{quick sort}}
    \paragraph{}
    La fonction de tri \emph{quick sort} vue au cours est implémentée dans le fichier \emph{sort.c}. La signature de la fonction est la même que celle de la fonction \emph{qsort} de la librairie standard \emph{stdlib} afin de  comparer facilement le temps d'exécution de la fonction implémentée par le programme et celle de la librairie standard.

    \paragraph{}
    La particularité de cette fonction est de trier un tableau d'éléments dont le type n'est pas connu. Le pointeur du tableau est passé en paramètre à la fonction avec le nombre d'éléments qui le composent et la taille d'un élément. Cette particularité rend impossible l'accès direct à un élément du tableau par un appel classique de type \texttt{tableau[i]}. Cet accès est implémenté par la fonction privée \texttt{void *\_elem(void *ptr, size\_t element\_size, size\_t i)}.

    \paragraph{}
    Les fonctions utilitaires privées sont appelées par l'intermédiaire de macros pour pouvoir être appelées sans leur passer des arguments qui sont toujours les mêmes. Par exemple, la fonction qui retourne un élément du tableau à un index donnée est définie comme suit :
    \begin{verbatimtab}
        #define QSORT_ELEM(__i)         _elem(ptr, element_size, __i)
    \end{verbatimtab}
    Elle sera appelée uniquement dans la fonction privée \texttt{\_quick\_sort} ou \texttt{ptr} (le pointeur du tableau à trier) et \texttt{element\_size} sont connus et ne changent pas. L'index \texttt{\_\_i} qui lui est différent à chaque appel est passé en paramètre à la macro.

    \paragraph{}
    Enfin, les éléments du tableau sont comparés par la fonction de comparaison passée en paramètre au \emph{quick sort}. Si besoin, ils sont intervertis par la fonction \texttt{\_swap}.


    \subsection{Fonctions de recherches}
    \paragraph{}
    Les fonctions de recherches sont des fonctions d'exploitation de la base de données. Elles sont donc accessibles uniquement via le mode utilisateurs.

    \paragraph{}
    Les fonctions de recherches à proprement parler (séquentielle, dichotomique et par index) sont séparées des fonctions qui les exploitent, que ce soit pour l'affichage en console ou la génération de rapport. Ces fonctions de recherches sont implémentées dans le dossier \emph{search}, les affichages en console dans le dossier \emph{display\_search} et les rapports dans le dossier \emph{report}.

    \paragraph{}
    Les fonctions de recherches génériques du dossier \emph{search} revoient des listes chainées de structures de type \texttt{search\_result} définie dans le fichier \emph{search\_result.h}. L'implémentation des listes chaînées est détaillée plus loin dans ce travail.

    \paragraph{}
    Il est enfin possible de trier les listes de résultats grâce à la fonction de tri implémentée dans le fichier \emph{search\_result.c}. Cette fonction générique prend en paramètres une liste de résultats et une fonction de comparaison. Elle utilise l'algorithme \emph{quick sort} après transformation de la liste chaînée en tableau.


    \subsection{Recherche par accès direct}
    \paragraph{}
    Les recherches par accès direct ne sont pas utilisées directement dans les menus de recherches mais par l'intermédiaire d'autres recherches. Par exemple, la génération du rapport des compagnies par groupe fait une recherche directe de groupe par l'identifiant cherché par l'utilisateur. La recherche directe est alors une recherche dans le buffer chargé en mémoire RAM.

    \paragraph{}
    L'implémentation d'une fonction de recherche directe ne nécessite pas d'implémentation particulière. En effet, il suffit d'accéder directement au tuple cherché par un appel classique dans le buffer de type \texttt{buffer[id-1]}. Pour une recherche directe dans le fichier de données, il aurait fallu implémenter une lecture dans le fichier de données sur base d'un offset calculé à partir de l'id recherché, de l'offset de la table et de la taille du tuple.


    \subsection{Recherche séquentielle}
    \paragraph{}
    Une fonction générique de recherche séquentielle est implémentée dans le fichier \emph{sequential\_search.c}. Elle constitue la liste de résultats à partir de la fonction de comparaison définies dans les métadonnées des tables.

    \paragraph{}
    Elle est exploitée par les recherches implémentées dans \emph{display\_sequential\_search.c} : recherches de pays, de job, d'industrie et de groupe par début de chaîne de caractère. Ces recherches demandent à l'utilisateur la chaîne de caractère cherchée pour rechercher :
    \begin{itemize}[label=$\bullet$]
        \item un pays par début de nom, de zone ou de code ISO (implémentation dans \emph{country.c})
        \item un job par début de nom, de niveau ou de département (implémentation dans \emph{job.c})
        \item une industrie par début de nom ou de secteur (implémentation dans \emph{industry.c})
        \item un groupe par début de nom (implémentation dans \emph{group.c})
    \end{itemize}

    \paragraph{}
    Toutes ces recherches sont insensibles à la casse.

    \paragraph{}
    La liste de résultats trouvée est affichée par une fonction générique de pagination implémentée dans \emph{ui\_utils.c}. Elle est triée par identifiant puisque les tuples sont parcourus séquentiellement et que les base de données sont triées sur base des identifiants. Elle est affichée à l'endroit ou à l'envers selon le choix de l'utilisateur (à l'endroit par défaut).


    \subsection{Recherche dichotomique}
    \paragraph{}
    Le fichier \emph{binary\_search.c} implémente la fonction générique de recherche dichotomique selon l'algorithme récursif vu au cours. Cet algorithme est utilisé pour les recherches par identifiant. Puisqu'il est unique, un seul résultat est retourné : l'offset du tuple trouvé ou celui du tuple le plus proche.

    \paragraph{}
    La recherche dichotomique est utilisée par la fonction générique \texttt{display\_search\_by\_id} du fichier \emph{display\_binary\_search.c}. Un identifiant est demandé à l'utilisateur et passé en paramètre à la recherche dichotomique. Si l'utilisateur entre \texttt{0}, le programme revient au menu principal n'effectue pas la recherche et l'utilisateur peut revenir au menu principal. Sinon, il affiche le tuple trouvé ou les identifiants des trois tuples les plus proches de celui cherché.

    \paragraph{}
    Il est à noter que la recherche de groupe par identifiant aurait plutôt pu être implémentée par un accès direct dans le buffer de groupes.


    \subsection{Recherche via index numérique}
    \paragraph{}
    Les index numériques sont exploités par la fonction de recherche implémentée dans \emph{num\_index\_search.c}. Cette fonction trouve la première occurrence correspondant à la recherche dans l'index et retourne la liste de résultats à partir de celle-ci.

    \paragraph{}
    Les recherches par index numérique affichées en console sont implémentées par une fonction générique dans le fichier \emph{display\_num\_index\_search.c} qui permet de chercher des personnes par identifiant de compagnie. L'identifiant est demandé à l'utilisateur est la liste est affichée par la fonction de pagination. Elle est triée par ordre alphabétique sur le nom de famille des personnes et est affichée à l'endroit ou à l'envers selon le choix de l'utilisateur.

    \paragraph{}
    Les rapports utilisent également la recherche numérique:
    \begin{itemize}[label=$\bullet$]
        \item Le rapport de compagnies par identifiant de groupe companies utilise l'index \emph{company by group id}
        \item Le rapport des employés d'un groupe classés par compagnie utilise l'index \emph{company by group id} pour trouver la liste des compagnies du groupe et l'index \emph{person by company id} pour trouver la liste des employés de chaque compagnie
        \item Le rapport du compte des employés d'un groupe utilise les mêmes index pour trouver les employés du groupe
        \item Le rapport sur les valeurs des actions détenues par les employés d'un groupe utilise les mêmes index pour trouver les employés du groupe
    \end{itemize}

    \paragraph{}
    Dans tous les cas, les listes de personnes sont triées par ordre alphabétique par nom de famille. Le programme n'intègre toutefois pas le tri dans la recherche par index numérique car une autre utilisation pourrait ne pas vouloir trier la liste ou la trier selon un autre champ.
    

    \subsection{Recherche via index alphanumérique}
    \paragraph{}
    La recherche par index alphanumérique est implémentée dans le fichier \emph{alpha\_index\_search.c}. De la même manière que la recherche par index numérique, elle retourne une liste de résultats à partir de la première occurrence correspondant à la recherche trouvée dans l'arbre binaire.

    \paragraph{}
    Cette recherche est utilisée dans \emph{display\_alpha\_index\_search.c} pour afficher la liste de personnes par début de nom. La liste n'est pas triée puisque l'index alphanumérique trie déjà les personnes par nom de famille. Ce tri est donc conservé à l'affichage et peut être inversé selon le choix de l'utilisateur.
    

    \subsection{Liste doublement chaînée}
    Le programme implémente une structure générique de liste doublement chaînée dont la structure est définie dans \emph{linked\_list.h}. Cette liste est composée d'une donnée : un pointeur de \emph{void} qui peut donc correspondre à n'importe quel type de donnée ou de structure. Elle contient le pointeur de l'élément suivant et de l'élément précédent.

    \paragraph{}
    Le fichier \emph{linked\_list.c} implémente les fonctions d'ajout d'un nouvel élément à la liste et de suppression de la liste, avec ou non une libération de la mémoire des données contenues dans la liste.


    \subsection{Logger}
    \paragraph{}
    Toutes les fonctions d'exploitation de la base de données écrivent des informations dans un fichier de log. Ce logger est implémenté dans le fichier \emph{logger.c} : il permet d'afficher un message d'erreur à la façon de \texttt{perror} en exploitant la valeur de \texttt{errno} ou d'afficher toute autre information précédée de l'endroit d'où provient le log.



    \newpage
    \section{Structure de fichiers}
    \paragraph{}
    En résumé de la description du programme, voici la structure de fichiers de mon programme. Le dossier \emph{src} n'est pas développé pour ne pas répéter la structure de fichiers déjà détaillée dans le dossier \emph{include}. Seuls certains fichiers sont uniquement des headers et ne contiennent pas de prototype de fonction à implémenter dans les sources.
 
    \begin{verbatimtab}
    - data_clients (dossier créé par le programme)
        db_clients.dat (fichier de données binaires)
        db_clients.log (fichier de logs généré par l'application)
    - data_export (dossier créé par le programme lors de l'export de données)
        Company_Export_Datetime.csv (date et heure auxquelles le fichier a été généré)
        Country_Export_Datetime.csv
        Group_Export_Datetime.csv
        Industry_Export_Datetime.csv
        Job_Export_Datetime.csv
        Person_Export_Datetime.csv
    - data_import (dossier qui doit être présent avec les six fichiers d'import
                    au moment de l'import dans le fichier binaire de données)
        DB_Company.csv
        DB_Country.csv
        DB_Group.csv
        DB_Industry.csv
        DB_Job.csv
        DB_Person.csv
    - include (headers des fichiers sources)
        - db_file
            admin.h (fonctions d'administration de la base de données)
            alpha_index.h (création d'index alphanumérique utilisant un arbre binaire)
            catalog.h (définitions des structures des tuples et des métadonnées)
            database.h (définition des structures de données gardées en mémoire RAM)
            header.h (création du header pour une base de données vide)
            num_index.h (création d'un index numérique)
            open_close.h (fonctions d'ouverture et de fermeture du fichier de données)
        - display_search (recherches dont les résultats sont listés en console)
            display_alpha_index_search.h
                recherche de personnes par nom de famille (tri par nom de famille)
            display_binary_search.h
                recherche d'un groupe par id
                recherche d'une compagnie par id
                recherche d'une personne par id
            display_num_index_search.h
                recherche de personnes par id de compagnie
            display_search.h (rassemble les headers pour simplifier les inclusions)
            display_sequential_search.h
                recherche par début de chaîne de caractère dans les tables de codes
                (pays, job, industrie, groupe)
        - report
            companies_by_group.h
                compagnies d'un groupe (par id) groupées par pays (rapport de détail)
            people_by_group.h
                employés d'un groupe (par id) groupés par compagnie (rapport de détail)
            people_count_by_group.h 
                pourcentage d'employés connus d'un groupe par id (rapport agrégé)
            people_shares_sum.h
                somme d'actions détenues par les employés d'un groupe présentant
                les statistiques par niveau de fonction et par genre (rapport agrégé)
            report_file.h (création d'un fichier texte de rapport)
            report.h (rassemble les headers pour simplifier les inclusions)
        - search
            alpha_index_search.h (recherche par index alphanumérique générique)
            binary_search.h (recherche dichotomique générique)
            num_index_search.h (recherche par index numérique générique)
            search_result.h (structure des résultats de recherche et fonction de tri)
            sequential_search.h (fonction générique de recherche séquentielle)
        - table (fonctions de manipulation des tables)
            company.h
            country.h
            group.h
            industry.h
            job.h
            person.h
        - ui
            menus.h (menus déclaratifs)
            ui_utils.h (interface utilisateur)
                récupération d'inputs : nombre, chaîne de caractères, oui/non
                affichages : liste paginée, détails d'un record (ou résultat
                    le plus proche), pause du programme
        - utils
            linked_list.h (gestion de liste doublement chaînée générique)
            logger.h (log d'information dans le fichier db_clients.log)
            preprocess_string.h (macro de transformation d'un nombre en string)
            sort.h (algorithme de tri quick sort)
            string_utils.h (fonctions utilitaires sur les chaînes de caractères :
                comparaisons, remplacement d'un caractère, mise en minuscules)
            system.h (fonction dépendant du système d'exploitation)
    + out (dossier dans lequel sont placés les fichiers objets compilés)
    + src (implémentations des headers, contient le main)
    + tests (fichiers de tests)
    Makefile (fichier utilisé pour compiler le projet)
    \end{verbatimtab}



    \section{Structure du fichier database}
    \paragraph{}
    Le fichier de données \emph{db\_clients.dat} est un fichier binaire d'une taille totale de 208 MB (208 224 128  bytes) composée de :
    \begin{itemize}[label=$\bullet$]
        \item un header (128 bytes)
        \item 100 tuples dans la table \emph{country} ($100 \times 64 \text{bytes} = 6400 \text{bytes}$)
        \item 200 tuples dans la table \emph{job} ($200 \times 96 \text{bytes} = 19200 \text{bytes}$)
        \item 100 tuples dans la table \emph{industry} ($100 \times 64 \text{bytes} = 6400 \text{bytes}$)
        \item 3000 tuples dans la table \emph{group} ($3000 \times 64 \text{bytes} = 192000 \text{bytes}$)
        \item 100 000 tuples dans la table \emph{company} ($100000 \times 288 \text{bytes} = 28800000 \text{bytes}$)
        \item 500 000 tuples dans la table \emph{person} ($500000 \times 224 \text{bytes} = 112000000 \text{bytes}$)
        \item 100 000 tuples dans l'index numérique \emph{company by group id} ($100000 \times 32 \text{bytes} = 3200000 \text{bytes}$)
        \item 500 000 tuples dans l'index numérique \emph{person by company id} ($500000 \times 32 \text{bytes} = 16000000 \text{bytes}$)
        \item 500 000 tuples dans l'index alphanumérique \emph{person by lastname} ($500000 \times 96 \text{bytes} = 48000000 \text{bytes}$)
    \end{itemize}



    \newpage
    \section{Tests}
    Vérifications de l'import de données avec le fichier d'export + diff.
    Vérification de la taille du fichier et des différents offsets dans le fichier binaire par rapport aux tailles calculées, aux tailles théoriques.


    \subsection{Tests unitaires}

    \subsection{Fichier de logs}

    \subsection{}

    \section{Problèmes rencontrés}

    CONCEPTION DU PROGRAMME:
    J'ai commencé par reprendre le menu développé pour le projet "agenda" mais avec amélioration. L'amélioration principale: menus déclaratifs -> beaucoup plus simple d'ajouter de nouveaux menus (pas de code à modifier dans le gestion des menus, juste ajouter un menu (titre + action) dans les menus du mode admin ou du mode user dans menu.c (et évidemment implémenter la méthode) et mettre à jour le compte dans le menu.h)

    Difficulté: les fichiers csv entre win et linux (aka ces putain de retour charriot)

    IMPLEMENTATION DES RECHERCHES DANS LES TABLES DE CODE :
    choix d'un tableau pour les buffers car petite taille + garder possibilité

    ces tables sont stockées dans des buffers
    si on entre juste enter, c'est la table entière qui est affichée




    TESTS:
ECRITURE DU MAIN
    tests au fur et à mesure de l'écriture du programme
    exemple : que se passe-t-il s'il est impossible de créer le log file :
    test avec un directory qui n'existe pas et qui n'est pas crée par le programme:
    % screenshots/log_file_fail.png
    quand le directory est créé, on passe au message d'erreur suivant : il n'y a pas de fichier de base de données (en effet, le mode "user" rassemble les fonctions de lecture et d'expoitation de la base de données -> il faut d'abord créer cette base de données en mode admin)
    % log_file_success_db_file_fail.png
    plus tard, quand la base de données aura été créée en mode admin, on aura accès au menu :

MENU PRINCIPAL :
    test des entrées non valides au clavier : caractère, chaîne de caractère, nombre négatif -> "Please enter an unsigned integer"
    Enter -> rien
    entrer un nombre supérieur au nombre de menus -> "[13] is not a valid menu"
    Nombre entier suivi d'autre chose ("1 2", "1.2", "1a") -> prend le premier integer lisible
    => une chaine de caractère qui ne commence pas par un chiffre n'est pas prise en compte mais si commence par un nombre, prend le premier unsigned int valides
    => on pourrait imaginer de n'accepter que les integer entrés seuls mais ce n'est pas l'objet du programme qui fonctionne très bien comme ça par ailleurs

    Dans le menu admin, de manière générale, peu de restrictions sont présentes quant aux possibilités de l'utilisateur (pas de demande de type "êtes vous sûr" avant de supprimer la DB par exemple).
    Je ne l'ai pas fait parce que j'ai supposé que le mode admin ne serait utilisé que par quelqu'un qui a le droit d'avoir accès à ces fonctionnalité: plutôt que de blinder chaquer méthode séparément, l'application pourrait plutôt être améliorée en restreignant l'accès à ce mode (par login/pwd). C'est d'ailleurs en partie pour cette raison que j'ai séparé ces fonctionnalités dans un autre mode (ça et le fait que le coeur du projet, c'est l'exploitation de la DB -> ne pas alourdir ces fonctions/ ce menu d'exploitation, et en plus on peut rajouter des fonctions "utilitaires" de gestion de la DB pas demandées dans le cahier des charges -> pratiques pour le développement -> mais pas fournie à l'utilisateur final (c'est le cas du delete))


    DIFFICULTES :

    - gestion des log cf telegram
    - généralisation : où s'arrêter, que généraliser (généralement, ça vient quand on commence à répéter beaucoup la mêm echose, pas possibel de savoit à l'avance quoi ggénéraliser, en tout cas quand c'est la première fois qu'on écrit ce type de programme, ie sans expérience)

    
\end{document}
